= Djinn

Djinn is a very basic helper for building simple daemons.

== Non-Rails Example

  #!/usr/bin/env ruby

  require 'rubygems'
  require 'djinn'

  class Basic
  
    include Djinn
  
    # Not providing a "perform" method falls back to the base method 
    # in Djinn, which does nothing useful. Make sure your method accepts
    # a config hash, even if it doesn't use it.
    def perform options
      log "ZOMG! A Djinn?"
    end
  
    # Strictly optional, lets you do stuff when the Djinn daemon stops.
    # The call to "super" is required, or your daemon will never die
    def handle_exit
      log "Handling a nice graceful exit.."
      super
    end
  
  end

Run it in the foreground like this:

  djinn = Basic.new
  djinn.run
  
But running it in the background is sort of the point. A bit contrived, but
this is the general idea:

  djinn.start
  sleep(10)
  djinn.stop
  
Assuming you didn't sleep there your script would end and the daemon would
detach and run in the background until it dies or gets killed. You can wrap
argument parsing around that if you want, or do it in any other way. By default 
the daemon will look for a config YAML file in same directory as you executed it
from, named the same as the Djinn class, so in this case _basic.yml_. It will by
default create the pid and log files in the same way. You can change this by 
putting it in the config file or supplying an options hash:

  options = {
    'pid_file_path' => 'path/to/pid/file',
    'log_file_path' => 'path/to/log/file'
  }
  
  djinn.start(options)
  
These options will also be passed to your *perform* method, so you can include
anything you need in the hash as well, or in the YAML file for that matter.
  
It might seem ugly, but the solution is minimal, and so remains flexible I think. 
The rails daemon helpers are an implementation on top of this illustrating how it 
can be tailored to include some option parsing and so forth, and so do a little 
more for you.
  
== Rails Example

There's a simple example in the example directory if you check the code out, but
here's the gist of it.

Assumes a scenario where you have a Book model that keeps a count of how many
times a book has been read.  

Create a file in RAILS_ROOT/lib or somewhere similar:

  require 'djinn/rails'

  class BookDjinn
  
    BOOK_WORKER_INTERVAL = 5
  
    include Djinn::Rails

    def perform config
      EM.run do
        log "Workers will run every #{BOOK_WORKER_INTERVAL} secs"
        EM::PeriodicTimer.new(BOOK_WORKER_INTERVAL) do
          log "There are #{Book.count} book(s) in the database"
          log "Updating read counts for all books.."
          Book.all.each &:read!
        end
      end
    end

    def handle_exit
      EM.stop
      super
    end

  end

Right, now you need to start it somehow. The easiest way is to create a file 
in RAILS_ROOT/scripts and pop this in it:

  #!/usr/bin/env ruby
  require 'rubygems'
  require File.join(File.dirname(__FILE__), '../lib/book_djinn')
  BookDjinn.go ARGV
 
Righto, now start it from RAILS_ROOT:

  ruby script/book_djinn
  
Okay, but that defaults to _run_, which starts it in the foreground and also 
uses the rails development environment by default. Try this:

  ruby script/book_djinn --help
  
That should give you a better idea of what's going on, then try this:

  ruby script/book_djinn start -e production
  
Yay, we have a daemon running in the background! To stop it:

  ruby script/book_djinn stop
  
That gives you more-or-less everything you need to build something basic
and monitor it with god or a similar process monitor.
  
== TODO

Lots. Keep 'em peeled.

== Copyright

Copyright (c) 2010 Craig Paterson. See LICENSE for details.
